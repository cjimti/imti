<!DOCTYPE html>
<html lang="en-us">
<head><head>
    <meta name="google-site-verification" content="" />
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="description" content="I lead a talented team of software development and creative engineers, covering many industries looking to collect, analyze, move, buffer, queue, process and present data in significant ways. My expertise and that of my team revolve around microservices, artificial intelligence, algorithms, machine learning and blockchain technologies.">
    
    <meta name="keyword"  content="Go, Kubernetes, Elasticsearch, Python, Docker, Big Data, Artificial Intelligence, Machine Learning, Blockchain">
    <link rel="shortcut icon" href="https://mk2.imti.co/img/favicon.ico">

    <title>High Traffic JSON Data into Elasticsearch on Kubernetes-IMTI | Craig Johnston</title>

    <link rel="canonical" href="https://mk2.imti.co/post-json-elasticsearch-kubernetes/">

    <link rel="stylesheet" href="https://mk2.imti.co/css/iDisqus.min.css"/>
	
    
    <link rel="stylesheet" href="https://mk2.imti.co/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="https://mk2.imti.co/css/hux-blog.min.css">

    
    <link rel="stylesheet" href="https://mk2.imti.co/css/syntax.css">

    
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    
    
    <link rel="stylesheet" href="/css/imti.css">

    
    <script src="https://mk2.imti.co/js/jquery.min.js"></script>
    
    
    <script src="https://mk2.imti.co/js/bootstrap.min.js"></script>
    
    
    <script src="https://mk2.imti.co/js/hux-blog.min.js"></script>

    <meta name="twitter:site" content="@cjimti">
<meta name="twitter:creator" content="@cjimti">

<meta name="twitter:description" content="IOT devices, Point-of-Sale systems, application events or any client that sends data destined for indexing in Elasticsearch often need to send and forget, however, unless that data is of low value there needs to be assurance that arrives at its final destination. Back-pressure and database outages can pose a considerable threat to data integrity.
 Contents     Background Overview Development Environment  the-project Namespace  The Project: Weather (wx) Data rxtx for Store-and-Forward  wx-rxtx Service wx-rxtx StatefulSet  rtBeat to Collect, Buffer and Publish  wx-rtbeat Service wx-rtbeat ConfigMap wx-rtbeat Deployment  Client Simulation / Kubernetes Cron Performance Conclusion Reference     Background High availability and high performance often mean burdensome complexity." />
<meta name="twitter:title" content="High Traffic JSON Data into Elasticsearch on Kubernetes" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://mk2.imti.co/img/post/firehose_876_438.jpg" />
<meta property="og:image" content="https://mk2.imti.co/img/post/firehose_876_438.jpg" />



    
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mk2.imti.co/post-json-elasticsearch-kubernetes/"
  },
  "headline": "High Traffic JSON Data into Elasticsearch on Kubernetes",
  "image": [
    "https://mk2.imti.co/img/post/firehose_876_438.jpg"
   ],
  "datePublished": "2018-07-18T00:00:00",
  "dateModified": "2018-07-18T00:00:00",
  "author": {
    "@type": "Person",
    "name": "Craig Johnston"
  },
   "publisher": {
    "@type": "Organization",
    "name": 'imti.co",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mk2.imti.co/img/craig_johnston_cjimti.jpg"
    }
  },
  "description": "IOT devices, Point-of-Sale systems, application events or any client that sends data destined for indexing in Elasticsearch often need to send and forget, however, unless that data is of low value there needs to be assurance that arrives at its final destination. Back-pressure and database outages can pose a considerable threat to data integrity.
 Contents     Background Overview Development Environment  the-project Namespace  The Project: Weather (wx) Data rxtx for Store-and-Forward  wx-rxtx Service wx-rxtx StatefulSet  rtBeat to Collect, Buffer and Publish  wx-rtbeat Service wx-rtbeat ConfigMap wx-rtbeat Deployment  Client Simulation / Kubernetes Cron Performance Conclusion Reference     Background High availability and high performance often mean burdensome complexity."
}
</script>

</head></head>

<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://mk2.imti.co/">IMTI</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="https://mk2.imti.co/">Home</a>
                    </li>
                    

                    
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header{
        background-image: url('https://mk2.imti.co/img/post/firehose.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/kubernetes" title="Kubernetes">
                        Kubernetes
                        </a>
                        
                        <a class="tag" href="/tags/elasticsearch" title="Elasticsearch">
                        Elasticsearch
                        </a>
                        
                        <a class="tag" href="/tags/data" title="Data">
                        Data
                        </a>
                        
                        <a class="tag" href="/tags/json" title="JSON">
                        JSON
                        </a>
                        
                    </div>
                    <h1>High Traffic JSON Data into Elasticsearch on Kubernetes</h1>
                    <h2 class="subheading">Instant, reliable, send and forget.</h2>
                    <span  class="meta">Posted by Craig Johnston on Wednesday, July 18, 2018
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                

<p>IOT devices, Point-of-Sale systems, application events or any client that sends data destined for indexing in Elasticsearch often need to send and forget, however, unless that data is of low value there needs to be assurance that arrives at its final destination. Back-pressure and database outages can pose a considerable threat to data integrity.</p>

<aside class="toc">
    <header>
        <h2>Contents</h2>
    </header>
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#background">Background</a></li>
<li><a href="#overview">Overview</a></li>
<li><a href="#development-environment">Development Environment</a>
<ul>
<li><a href="#the-project-namespace">the-project Namespace</a></li>
</ul></li>
<li><a href="#the-project-weather-wx-data">The Project: Weather (wx) Data</a></li>
<li><a href="#rxtx-for-store-and-forward"><a href="https://hub.docker.com/r/txn2/rxtx/">rxtx</a> for Store-and-Forward</a>
<ul>
<li><a href="#wx-rxtx-service">wx-rxtx Service</a></li>
<li><a href="#wx-rxtx-statefulset">wx-rxtx StatefulSet</a></li>
</ul></li>
<li><a href="#rtbeat-to-collect-buffer-and-publish"><a href="https://hub.docker.com/r/txn2/rtbeat/">rtBeat</a> to Collect, Buffer and Publish</a>
<ul>
<li><a href="#wx-rtbeat-service">wx-rtbeat Service</a></li>
<li><a href="#wx-rtbeat-configmap">wx-rtbeat ConfigMap</a></li>
<li><a href="#wx-rtbeat-deployment">wx-rtbeat Deployment</a></li>
</ul></li>
<li><a href="#client-simulation-kubernetes-cron">Client Simulation / Kubernetes Cron</a></li>
<li><a href="#performance">Performance</a></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#reference">Reference</a></li>
</ul></li>
</ul>
</nav>
</aside>

<h2 id="background">Background</h2>

<p>High availability and high performance often mean burdensome complexity. Data replication, application, network and infrastructure redundancy, anything we can do to avoid a single point of failure. However, what happens when one of those points do fail? Alternatively, a cascade of problems causing slowdowns and back pressure builds to constant far too high for indexing to catch up?</p>

<p><a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">Pub-Sub</a> style message queues like Kafka are growing in popularity because they add incredible flexibility to data pipelines, yet these queues can also suffer from data loss and duplication unless you expend sufficient effort in expert tuning and configuration. <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">Pub-Sub</a> MQs can also over complicate the architecture depending on requirements. I found myself re-thinking some of my architectures after reading <a href="https://www.programmableweb.com/news/why-messaging-queues-suck/analysis/2017/02/13">Why Messaging Queues Suck</a> by Bob Reselman. I still use messaging queues but have pushed <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">Pub-Sub</a> further back from the edge of my stack.</p>

<p>Over the years I have made conscious efforts to move complexity further from the edge. The edge, being the API endpoints relied upon by clients. If I can simplify and harden the edges, then the more sensitive and complex systems deeper down have less exposure to unknowns. An early layer of simplicity not only buffers API calls and data but moves complexity back a rung.</p>

<h2 id="overview">Overview</h2>

<p>In the process below I demonstrate a store and forward setup used for asynchronous data gathering. The clients need to send data, and I need assurance that data makes it to its destination. I don&rsquo;t need the clients waiting for confirmation.</p>

<p><img src="/images/content/txn2/rxtx-rtbeat.png" alt="" /></p>

<p>I use <a href="https://hub.docker.com/r/txn2/rxtx/">rxtx</a> to store-and-forward data to <a href="https://hub.docker.com/r/txn2/rtbeat/">rtBeat</a> which publishes it into Elasticsearch. This process of store-and-forward achieved through a batching message queue that can function independently or as a first layer of buffering to larger message queue applications.</p>

<p>Using <a href="https://hub.docker.com/r/txn2/rxtx/">rxtx</a> with <a href="https://hub.docker.com/r/txn2/rtbeat/">rtBeat</a> you can achieve high performance, highly available service for accepting JSON POST data and delivering it to Elasticsearch. <a href="https://hub.docker.com/r/txn2/rxtx/">rxtx</a> collects post data, writes it to a local <a href="https://github.com/coreos/bbolt">bbolt</a> database and sends batches on an interval to rtBeat. <a href="https://hub.docker.com/r/txn2/rtbeat/">rtBeat</a> processes the batches of POSTed JSON data and publishes them as events into Elasticsearch. <a href="https://hub.docker.com/r/txn2/rtbeat/">rtBeat</a> is an Elastic <a href="https://www.elastic.co/products/beats">beat</a> and can publish simultaneously to <a href="https://www.elastic.co/">elasticsearch</a>, <a href="https://www.elastic.co/products/logstash">logstash</a>, <a href="https://kafka.apache.org/">kafka</a> and <a href="https://redis.io/">redis</a>.</p>

<h2 id="development-environment">Development Environment</h2>

<p>You need a Kubernetes cluster and an Elasticsearch database running in it. If you don&rsquo;t have a Kubernetes cluster or would like to create a production-like cluster for development or research, I suggest the following articles:</p>

<ul>
<li><a href="/hobby-cluster/">Production Hobby Cluster</a></li>
<li><a href="/kubernetes-production-elasticsearch/">Production Grade Elasticsearch on Kubernetes</a></li>
<li><a href="/kibana-kubernetes/">Kibana on Kubernetes</a></li>
</ul>

<h3 id="the-project-namespace">the-project Namespace</h3>

<p>In continuity with previous tutorials, I&rsquo;ll stick with <code>the-project</code> <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/">namespace</a>.</p>

<p><code>00-namespace.yml</code>:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: Namespace
metadata:
  name: the-project
  labels:
    env: dev
</code></pre>

<p>Create the namespace:</p>

<pre><code class="language-bash">kubectl create -f 00-namespace.yml
</code></pre>

<h2 id="the-project-weather-wx-data">The Project: Weather (wx) Data</h2>

<p>In this tutorial, I use weather (wx) data from the <a href="https://darksky.net/dev">Dark Sky API</a>. Since the <a href="https://darksky.net/dev">Dark Sky API</a> is a service for pulling data, I use a Kubernetes <a href="#client-simulation--kubernetes-cron">cronjob</a> to pull from the <a href="https://darksky.net/dev">Dark Sky API</a> and push into the new service, simulating an IOT based weather client in Los Angeles. Pull and send is a familiar pattern for many data retrieval systems.</p>

<h2 id="rxtx-for-store-and-forward"><a href="https://hub.docker.com/r/txn2/rxtx/">rxtx</a> for Store-and-Forward</h2>

<p><a href="https://hub.docker.com/r/txn2/rxtx/"><img src="https://github.com/txn2/rxtx/raw/master/mast.jpg" alt="" /></a>
<a href="https://hub.docker.com/r/txn2/irsync/"><img src="https://shields.beevelop.com/docker/image/image-size/txn2/rxtx/latest.svg" alt="Docker Container Image Size" /></a>
<a href="https://hub.docker.com/r/txn2/irsync/"><img src="https://shields.beevelop.com/docker/image/layers/txn2/rxtx/latest.svg" alt="Docker Container Layers" /></a>
<a href="https://goreportcard.com/report/github.com/txn2/rxtx"><img src="https://goreportcard.com/badge/github.com/txn2/rxtx" alt="Go Report Card" /></a></p>

<p><a href="https://hub.docker.com/r/txn2/rxtx/">rxtx</a> is a queue based, store-and-forward data collector and data transmitter useful for online/offline data collection, back pressure buffering or general queuing. <a href="https://hub.docker.com/r/txn2/rxtx/">rxtx</a> uses the highly efficient and fast bbolt maintained by CoreOs. <a href="https://github.com/coreos/bbolt">bbolt</a> stores message awaiting an interval and the ability to send them.</p>

<p><a href="https://hub.docker.com/r/txn2/rxtx/">rxtx</a> is written in Golang and originally designed to run in a Docker container on IOT devices with intermittent network connectivity. Because of its simplistic design and network tolerance, it can be a safety net during unexpected outages or slowdown deeper in the system.</p>

<p><a href="https://hub.docker.com/r/txn2/rxtx/">rxtx</a> listens for HTTP POST requests with JSON data, it stores the data along with a timestamp and sequence number, on a defined interval <a href="https://hub.docker.com/r/txn2/rxtx/">rxtx</a> gathers a batch of JSON messages and in-turn POSTs them to a defined endpoint. <a href="https://hub.docker.com/r/txn2/rxtx/">rxtx</a> can POST to any endpoint accepting POST data yet is designed to work specifically with <a href="https://hub.docker.com/r/txn2/rtbeat/">rtBeat</a>, which we implement further down.</p>

<h3 id="wx-rxtx-service">wx-rxtx Service</h3>

<p>Kubernetes <a href="https://kubernetes.io/docs/concepts/services-networking/service/">Services</a> are the communication hub for a microservices architecture. Services are, and so it makes sense to set them up early on.</p>

<p>Our <strong>wx-rxtx</strong> service look for Pods with the label <strong>app: wx-rxtx</strong> and direct traffic to them on port 80 to port 80 on the Pods.</p>

<p><code>wx-rxtx/20-service.yml</code>:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: wx-rxtx
  namespace: the-project
  labels:
    app: wx-rxtx
    env: dev
spec:
  selector:
    app: wx-rxtx
  ports:
  - protocol: &quot;TCP&quot;
    port: 80
    targetPort: 80
  type: ClusterIP
</code></pre>

<p>Create the wx-rxtx service:</p>

<pre><code class="language-bash">kubectl create -f wx-rxtx/20-service.yml
</code></pre>

<p>Although it won&rsquo;t do much, at this point we do have a service listening at <a href="http://wx-rxtx:80/">http://wx-rxtx:80/</a> from inside the cluster; however, from outside <code>the-project</code> namespace it would need to be addressed <a href="http://the-project.wx-rxtx:80/">http://the-project.wx-rxtx:80/</a>.</p>

<h3 id="wx-rxtx-statefulset">wx-rxtx StatefulSet</h3>

<p>We use Kubernetes <a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a>s because unlike a Deployment, a <a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a> maintains a sticky identity for each of their Pods. <a href="https://hub.docker.com/r/txn2/rxtx/">rxtx</a> will use a <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">PersistentVolume</a> to store its <a href="https://github.com/coreos/bbolt">bbolt</a> database. If a Pod it restarted, or a Kubernetes node goes down, a new Pod eventually takes its place and attaches to the existing data.</p>

<p>I recommend running <a href="https://ceph.com/">Ceph</a> managed by <a href="https://rook.io/">rook</a>. &ldquo;Ceph is a unified, distributed storage system designed for excellent performance, reliability, and scalability.&rdquo; and &ldquo;Rook orchestrates battle-tested open-source storage technologies including Ceph.&rdquo;</p>

<p>Configuring <a href="https://ceph.com/">Ceph</a> to replicate your data ensures that with <a href="https://hub.docker.com/r/txn2/rxtx/">rxtx</a> every message is eventually sent, even with a catastrophic failure of multiple Kubernets nodes.</p>

<p>Setting up <a href="https://ceph.com/">Ceph</a> and <a href="https://rook.io/">rook</a> is beyond the scope of this article, but quickly done with their excellent documentation.</p>

<p><code>wx-rxtx/40-statefulset.yml</code>:</p>

<pre><code class="language-yaml">apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: wx-rxtx
  namespace: the-project
  labels:
    app: wx-rxtx
    env: dev
spec:
  serviceName: wx-rxtx
  replicas: 1 # scale as desired
  selector:
    matchLabels:
      app: wx-rxtx
  template:
    metadata:
      labels:
        app: wx-rxtx
        env: dev
    spec:
      containers:
      - name: wx-rxtx
        image: txn2/rxtx:1.2.0
        imagePullPolicy: Always
        args: [
          &quot;--ingest=http://wx-rtbeat:80/in&quot;,
          &quot;--port=80&quot;,
          &quot;--path=/data&quot;,
          &quot;--interval=10&quot;, # seconds between intervals
          &quot;--batch=4000&quot;,  # maximum batch size
          &quot;--maxq=500000&quot;] # maximum message to store
        volumeMounts:
        - name: wx-rxtx-data-volume
          mountPath: /data
        ports:
        - name: rxtx
          containerPort: 80
  volumeClaimTemplates:
  - metadata:
      name: wx-rxtx-data-volume
    spec:
      storageClassName: rook-block
      accessModes: [ ReadWriteOnce ]
      resources:
        requests:
          storage: 1Gi # enough to hold maxq
</code></pre>

<p>Create the wx-rxtx statefulset:</p>

<pre><code class="language-bash">kubectl create -f wx-rxtx/40-statefulset.yml
</code></pre>

<p>The <strong>wx-rxtx service</strong> should now be able to find <strong>wx-rxtx</strong> Pods deployed by the <a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a> and any data sent to the service <a href="http://wx-rxtx:80/">http://wx-rxtx:80/</a> is send to them.</p>

<h2 id="rtbeat-to-collect-buffer-and-publish"><a href="https://hub.docker.com/r/txn2/rtbeat/">rtBeat</a> to Collect, Buffer and Publish</h2>

<p><a href="https://hub.docker.com/r/txn2/rtbeat/"><img src="https://raw.githubusercontent.com/txn2/rtbeat/master/mast-logo.jpg" alt="" /></a>
<a href="https://hub.docker.com/r/txn2/irsync/"><img src="https://shields.beevelop.com/docker/image/image-size/txn2/rtbeat/latest.svg" alt="Docker Container Image Size" /></a>
<a href="https://hub.docker.com/r/txn2/rtbeat/"><img src="https://shields.beevelop.com/docker/image/layers/txn2/rtbeat/latest.svg" alt="Docker Container Layers" /></a>
<a href="https://goreportcard.com/report/github.com/txn2/rtbeat"><img src="https://goreportcard.com/badge/github.com/txn2/rtbeat" alt="Go Report Card" /></a></p>

<p><a href="https://github.com/txn2/rtbeat">rtBeat</a> processes HTTP POST data from <a href="https://github.com/txn2/rxtx">rxtx</a> and publishes events into <a href="https://www.elastic.co/">Elasticsearch</a>, <a href="https://www.elastic.co/products/logstash">Logstash</a>, <a href="https://kafka.apache.org/">Kafka</a>, <a href="https://redis.io/">Redis</a> or directly to log files.</p>

<p><a href="https://hub.docker.com/r/txn2/rtbeat/">rtBeat</a> is designed to accept batches of JSON data from <a href="https://hub.docker.com/r/txn2/rxtx/">rxtx</a> and publish these batches to Elasticsearch, Logstash, Kafka, and Redis. In this project, we are only publishing to <a href="https://www.elastic.co/">elasticsearch</a>. However, you can review the <a href="https://github.com/txn2/rtbeat/blob/master/rtbeat.reference.yml">rtBeat configuration</a> for these other systems.</p>

<h3 id="wx-rtbeat-service">wx-rtbeat Service</h3>

<p>wx-rtbeat listens internally on the cluster at <a href="http://wx-rtbeat:80">http://wx-rtbeat:80</a>, we can set up <a href="/web-cluster-ingress/">ingress</a> to point to this service in the future to allow external access.</p>

<p><code>wx-rtbeat/20-service.yml</code>:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: wx-rtbeat
  namespace: the-project
  labels:
    app: wx-rtbeat
    env: dev
spec:
  type: ClusterIP
  selector:
    app: wx-rtbeat
  ports:
  - name: rtbeat
    protocol: TCP
    port: 80
    targetPort: 80
</code></pre>

<p>Create the wx-rtbeat Service:</p>

<pre><code class="language-bash">kubectl create -f wx-rtbeat/20-service.yml
</code></pre>

<h3 id="wx-rtbeat-configmap">wx-rtbeat ConfigMap</h3>

<p>A significant part of configuring <a href="https://hub.docker.com/r/txn2/rtbeat/">rtbeat</a> involves mapping fields. Although Elastic search does a great job of detecting data types, it&rsquo;s best to be specific when you can. Since we are using data from the <a href="https://darksky.net/dev">Dark Sky API</a>, we can choose the most appropriate <a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.3/mapping-types.html">Elasticsearch data types</a>.</p>

<p>The following <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/">ConfigMap</a> mounts as a volume into the Pods running <a href="https://hub.docker.com/r/txn2/rtbeat/">rtbeat</a>.</p>

<p>Within the <strong>rtbeat.yml</strong> section under <strong>output.elasticsearch:</strong> you find <strong>hosts:</strong> set to <strong>&ldquo;elasticsearch:9200&rdquo;</strong>. The elasticsearch service running on port 9200 is setup in the tutorial <a href="/kubernetes-production-elasticsearch/">Production Grade Elasticsearch on Kubernetes</a>.</p>

<p><code>wx-rtbeat/30-configmap.yml</code>:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: wx-rtbeat
  namespace: the-project
  labels:
    app: wx-rtbeat
    env: dev
data:
  rtbeat.yml: |-
    rtbeat:
      # beat configuration
      # see https://github.com/txn2/rtbeat/blob/master/rtbeat.reference.yml
      port: &quot;80&quot;
      timeout: 5
      name: wx-rtbeat

    output.elasticsearch:
      # Array of hosts to connect to.
      hosts: [&quot;elasticsearch:9200&quot;]
      # Elasticsearch Index (new index each month)
      index: &quot;wx-rtbeat-%{+yyyy.MM}&quot;

    setup:
      template.name: &quot;wx-rtbeat&quot;
      template.pattern: &quot;wx-rtbeat-*&quot;
      template.fields: &quot;/config/fields.yml&quot;
      template.overwrite: true

    #setup.kibana:
    #  protocol: &quot;http&quot;
    #  host: &quot;kibana:80&quot;
    #  ssl.enabled: false

    # internal metrics through a HTTP endpoint
    http.enabled: true
    http.port: 5066

  fields.yml: |-
    - key: rxtx
      title: rtbeat
      # Data sent in from rxtx will be in batches of rxtxMsg objects where
      # the payload will hold the original post data and will be prefixed as such,
      # model the data here for proper indexing into Elasticsearch.
      # see https://www.elastic.co/guide/en/elasticsearch/reference/6.3/mapping-types.html
      description: &gt;
        “Powered by Dark Sky” - https://darksky.net/poweredby/
        The following fields are pulled from the Dark Sky API free tier allowing 1000 requests per day,
        see https://darksky.net/dev/docs for API documentation. The fields below only
        map to returned data excluding all but the &quot;currently&quot; key (exclude=minutely,hourly,daily,flags)
      fields:
      # rxtx standard fields (customizable)
      - name: rxtxMsg.seq
        required: true
        type: string
      - name: rxtxMsg.time
        required: true
        type: date
      - name: rxtxMsg.producer
        required: true
        type: keyword
      - name: rxtxMsg.label
        required: true
        type: keyword
      - name: rxtxMsg.key
        required: true
        type: keyword
      # custom
      - name: rxtxMsg.payload.latitude
        required: true
        type: half_float
      - name: rxtxMsg.payload.longitude
        required: true
        type: half_float
      - name: rxtxMsg.payload.timezone
        required: true
        type: keyword
      - name: rxtxMsg.payload.offset
        required: true
        type: byte
      - name: rxtxMsg.payload.currently.time
        required: true
        type: long
      - name: rxtxMsg.payload.currently.summary
        required: true
        type: keyword
      - name: rxtxMsg.payload.currently.icon
        required: true
        type: keyword
      - name: rxtxMsg.payload.currently.nearestStormDistance
        required: true
        type: integer
      - name: rxtxMsg.payload.currently.precipIntensity
        required: true
        type: half_float
      - name: rxtxMsg.payload.currently.precipIntensityError
        required: true
        type: half_float
      - name: rxtxMsg.payload.currently.precipProbability
        required: true
        type: half_float
      - name: rxtxMsg.payload.currently.precipType
        required: true
        type: keyword
      - name: rxtxMsg.payload.currently.temperature
        required: true
        type: half_float
      - name: rxtxMsg.payload.currently.apparentTemperature
        required: true
        type: half_float
      - name: rxtxMsg.payload.currently.dewPoint
        required: true
        type: half_float
      - name: rxtxMsg.payload.currently.humidity
        required: true
        type: half_float
      - name: rxtxMsg.payload.currently.pressure
        required: true
        type: half_float
      - name: rxtxMsg.payload.currently.windSpeed
        required: true
        type: half_float
      - name: rxtxMsg.payload.currently.windGust
        required: true
        type: half_float
      - name: rxtxMsg.payload.currently.windBearing
        required: true
        type: half_float
      - name: rxtxMsg.payload.currently.cloudCover
        required: true
        type: half_float
      - name: rxtxMsg.payload.currently.uvIndex
        required: true
        type: half_float
      - name: rxtxMsg.payload.currently.visibility
        required: true
        type: half_float
      - name: rxtxMsg.payload.currently.ozone
        required: true
        type: half_float

    - key: beat
      title: Beat
      description: &gt;
        Contains common beat fields available in all event types.
      fields:
        - name: beat.name
          description: &gt;
            The name of the Beat sending the log messages. If the Beat name is
            set in the configuration file, then that value is used. If it is not
            set, the hostname is used. To set the Beat name, use the `name`
            option in the configuration file.
        - name: beat.hostname
          description: &gt;
            The hostname as returned by the operating system on which the Beat is running.
        - name: beat.version
          description: &gt;
            The version of the beat that generated this event.

        - name: &quot;@timestamp&quot;
          type: date
          required: true
          format: date
          example: August 26th 2016, 12:35:53.332
          description: &gt;
            The timestamp when the event log record was generated.

        - name: tags
          description: &gt;
            Arbitrary tags that can be set per Beat and per transaction
            type.

        - name: fields
          type: object
          object_type: keyword
          description: &gt;
            Contains user configurable fields.

        - name: error
          type: group
          description: &gt;
            Error fields containing additional info in case of errors.
          fields:
            - name: message
              type: text
              description: &gt;
                Error message.
            - name: code
              type: long
              description: &gt;
                Error code.
            - name: type
              type: keyword
              description: &gt;
                Error type.
</code></pre>

<p>Create the wx-rtbeat ConfigMap:</p>

<pre><code class="language-bash">kubectl create -f wx-rtbeat/30-configmap.yml
</code></pre>

<h3 id="wx-rtbeat-deployment">wx-rtbeat Deployment</h3>

<p>The deployment creates a Pod running the <a href="https://hub.docker.com/r/txn2/rtbeat/">rtbeat</a> Docker container configured by the <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/">ConfigMap</a> we created above.</p>

<p><code>wx-rtbeat/40-depoloyment.yml</code>:</p>

<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: wx-rtbeat
  namespace: the-project
  labels:
    app: wx-rtbeat
    env: dev
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wx-rtbeat
  template:
    metadata:
      labels:
        app: wx-rtbeat
        env: dev
    spec:
      containers:
      - name: wx-rtbeat
        image: txn2/rtbeat:1.0.2
        imagePullPolicy: Always
        args: [&quot;-e&quot;, &quot;--path.config=/config&quot;]
        volumeMounts:
        - name: wx-rtbeat-config-volume
          mountPath: /config
        ports:
        - name: rtbeat
          containerPort: 80
      volumes:
      - name: wx-rtbeat-config-volume
        configMap:
          name: wx-rtbeat
</code></pre>

<p>Create the wx-rtbeat <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a>:</p>

<pre><code class="language-bash">kubectl create -f wx-rtbeat/40-deployment.yml
</code></pre>

<h2 id="client-simulation-kubernetes-cron">Client Simulation / Kubernetes Cron</h2>

<p>We could add an <a href="/web-cluster-ingress/">ingress</a> configuration and expose our wx-rtbeat service to the outside world, allowing IOT devices like weather stations, machine sensors, or anything that can POST JSON data to us. However, for this tutorial, we can more easily simulate a client using a Kubernetes <a href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/">CronJob</a>.</p>

<p>We create a <a href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/">CronJob</a> that issues a request to the <a href="https://darksky.net/dev">Dark Sky API</a>, receives JSON data and subsequently issues a POST directly to our <a href="https://hub.docker.com/r/txn2/rtbeat/">rtbeat</a> service.</p>

<p>I keep my <a href="https://darksky.net/dev">Dark Sky API</a> in a Secret and mount the value of the secret to an environment variable accessible in the container used by the cron.</p>

<ul>
<li>Sign up for a <a href="https://darksky.net/dev">Dark Sky API</a> developer account (free).</li>
<li>Create a file called <strong>apikey</strong> with your secret API key in it.</li>
</ul>

<p>Create the Kubernetes secret <strong>wx-data-api-key</strong> in <strong>the-project</strong> namespace:</p>

<pre><code class="language-bash">kubectl create secret generic wx-data-api-key --from-file=apikey -n the-project
</code></pre>

<p><code>wx-data/40-cron.yml</code>:</p>

<pre><code class="language-yaml">apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: wx-data
  namespace: the-project
  labels:
    app: wx-data
    env: dev
spec:
  schedule: &quot;*/2 * * * *&quot;
  concurrencyPolicy: Forbid
  startingDeadlineSeconds: 90
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: wx-data
            image: txn2/curl:v3.0.0
            env:
            - name: API_KEY
              valueFrom:
                secretKeyRef:
                  name: wx-data-api-key
                  key: apikey
            - name: DATA_FROM
              value: &quot;https://api.darksky.net/forecast/$(API_KEY)/33.8148455,-117.826581?exclude=minutely,hourly,daily,flags&quot;
            - name: DATA_TO
              value: &quot;http://wx-rxtx:80/rx/cron/collector/wx-data&quot;
            command: [
              &quot;/bin/sh&quot;,
              &quot;-c&quot;,
              &quot;/usr/bin/curl -sX GET $(DATA_FROM) &gt; data &amp;&amp; /usr/bin/curl -sX POST -d @data $(DATA_TO)&quot;
            ]
          restartPolicy: OnFailure
</code></pre>

<p>Create the wx-data <a href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/">CronJob</a>:</p>

<pre><code class="language-bash">kubectl create -f wx-data/40-cron.yml
</code></pre>

<h2 id="performance">Performance</h2>

<p>Inserting one record every two minutes is only to demonstrate the process. I run this setup on a few production systems that handle around 200 messages per second and often up to 400 or 500 with only minimal resource used other than data storage.</p>

<p>Scaled <a href="https://hub.docker.com/r/txn2/rtbeat/">rtBeat</a> and <a href="https://hub.docker.com/r/txn2/rxtx/">rxtx</a> by increasing the number of replicas to whatever your Kubernetes cluster can handle. <a href="https://hub.docker.com/r/txn2/rtbeat/">rtBeat</a> and <a href="https://hub.docker.com/r/txn2/rxtx/">rxtx</a> services run independently allowing infinite horizontal scaling.</p>

<h2 id="conclusion">Conclusion</h2>

<p>If you have setup <a href="/kibana-kubernetes/">Kibana on Kubernetes</a>, you should begin to see data. You are now able to set up an index, explore your data and create visualizations.</p>

<p><img src="/images/content/txn2/wx-kibana.png" alt="Kibana Dashboard" />
<img src="/images/content/txn2/wx-discover.png" alt="Kibana Discover" /></p>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="/hobby-cluster/">Production Hobby Cluster</a></li>
<li><a href="https://hub.docker.com/r/txn2/rtbeat/">rtBeat</a> Docker container</li>
<li><a href="https://hub.docker.com/r/txn2/rxtx/">rxtx</a> Docker container</li>
<li><a href="https://www.elastic.co/">Elasticsearch</a></li>
<li>Elastic <a href="https://www.elastic.co/products/beats">beat</a></li>
</ul>


                
<div id="disqus-comment"></div>



            </div>
            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/data" title="Data">
                        Data
                        </a>
                        
                        
                        
                        <a href="/tags/data-science" title="Data Science">
                        Data Science
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/devops" title="DevOps">
                        DevOps
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/docker" title="Docker">
                        Docker
                        </a>
                        
                        
                        
                        <a href="/tags/elasticsearch" title="Elasticsearch">
                        Elasticsearch
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/golang" title="Golang">
                        Golang
                        </a>
                        
                        
                        
                        <a href="/tags/ingress" title="Ingress">
                        Ingress
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/kubernetes" title="Kubernetes">
                        Kubernetes
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/microservices" title="Microservices">
                        Microservices
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/python" title="Python">
                        Python
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/security" title="Security">
                        Security
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/utils" title="Utils">
                        Utils
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/kubectl" title="kubectl">
                        kubectl
                        </a>
                        
                        
                        
                        
                        
                        
                    </div>
                </section>

                
                <hr>
                <h5>RELATED</h5>
                <ul class="list-inline">
                    
                </ul>
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                   
                   <li>
                       <a href="" rel="alternate" type="application/rss+xml" title="IMTI" >
                           <span class="fa-stack fa-lg">
                               <i class="fa fa-circle fa-stack-2x"></i>
                               <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                           </span>
                       </a>
                   </li>
                   
                    
                    <li>
                        <a href="mailto:cjimti@gmail.com">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		    
                    
                    
                    <li>
                        <a href="https://twitter.com/cjimti">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    

                    

		    
                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/cjimti">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		    
                    
                    <li>
                        <a target="_blank" href="https://www.linkedin.com/in/cjimti/">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		    
                </ul>
		<p class="copyright text-muted">
            Copyright &copy; <a href="">Craig Johnston</a> , 2018
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        async("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>



    
        
        
    





</body>
</html>
