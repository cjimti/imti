<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Raspberry Pi on IMTI</title>
    <link>https://imti.co/tags/raspberry-pi/</link>
    <description>Recent content in Raspberry Pi on IMTI</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 02 Apr 2018 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://imti.co/tags/raspberry-pi/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>rSync Files on Interval</title>
      <link>https://imti.co/raspberry-pi-rsync-interval/</link>
      <pubDate>Mon, 02 Apr 2018 00:00:00 +0000</pubDate>
      <guid>https://imti.co/raspberry-pi-rsync-interval/</guid>
      <description>&lt;p&gt;A recurring requirement for my &lt;a href=&#34;https://en.wikipedia.org/wiki/Internet_of_things&#34;&gt;IOT&lt;/a&gt; projects involves keeping a set of files synced with a central server. Many of these projects include media players, kiosk systems, or applications that need frequently updated configuration files, all while entirely unattended, and in most cases unreachable through firewalls. I have one project that alone has 2000+ devices pulling media continuously from an &lt;a href=&#34;https://en.wikipedia.org/wiki/Rsync&#34;&gt;rsync&lt;/a&gt; server. Many of these devices are on doggy wifi networks.&lt;/p&gt;&#xA;&lt;p&gt;The &lt;a href=&#34;https://en.wikipedia.org/wiki/Rsync&#34;&gt;rsync&lt;/a&gt; utility works excellent on &lt;a href=&#34;https://amzn.to/2qlJT3d&#34;&gt;Raspberry Pi&lt;/a&gt; as well as an assortment of &lt;a href=&#34;https://www.armbian.com/&#34;&gt;Armbian&lt;/a&gt; installed devices. However, writing scripts to manage &lt;a href=&#34;https://en.wikipedia.org/wiki/Rsync&#34;&gt;rsync&lt;/a&gt; when it fails, or restarting it on some interval when it finishes can be a pain. I have a dozen rickety, cobbled-together &lt;a href=&#34;https://www.gnu.org/software/bash/&#34;&gt;bash&lt;/a&gt; hacks that have somewhat worked in the past. I needed something more stable, portable and upgradeable.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Raspberry Pi 3 - WiFi Station&#43;AP</title>
      <link>https://imti.co/iot-wifi/</link>
      <pubDate>Thu, 15 Mar 2018 00:00:00 +0000</pubDate>
      <guid>https://imti.co/iot-wifi/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: Looking for contributors.&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;Golang&lt;/th&gt;&#xA;          &lt;th&gt;Size&lt;/th&gt;&#xA;          &lt;th&gt;Pulls&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;a href=&#34;https://goreportcard.com/report/github.com/cjimti/iotwifi&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/cjimti/iotwifi&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;a href=&#34;https://hub.docker.com/r/cjimti/iotwifi/&#34;&gt;&lt;img src=&#34;https://shields.beevelop.com/docker/image/image-size/cjimti/iotwifi/latest.svg&#34; alt=&#34;Docker Container Image Size&#34;&gt;&lt;/a&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;a href=&#34;https://hub.docker.com/r/cjimti/iotwifi/&#34;&gt;&lt;img src=&#34;https://img.shields.io/docker/pulls/cjimti/iotwifi.svg&#34; alt=&#34;Docker Container Pulls&#34;&gt;&lt;/a&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;IOT Wifi is very small/8MB &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; Container built for the &lt;a href=&#34;https://amzn.to/2jfXhCA&#34;&gt;Raspberry Pi 3&lt;/a&gt;.&#xA;IOT Wifi exposes a simple JSON based REST API for controlling the wireless network interface. This container allows the Raspberry Pi to accept wifi connections as an access point (aka AP) while at the same time connecting to an existing wifi network (station mode).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Raspberry Pi - Serial Number</title>
      <link>https://imti.co/raspberry-pi-serial/</link>
      <pubDate>Mon, 13 Feb 2017 00:00:00 +0000</pubDate>
      <guid>https://imti.co/raspberry-pi-serial/</guid>
      <description>&lt;p&gt;Getting the unique serial number from a Raspberry Pi.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;cat /proc/cpuinfo | grep ^Serial | cut -d&amp;quot;:&amp;quot; -f2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Example output:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt; 00000000e215b4a2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;An interesting use for this is &amp;ldquo;binding&amp;rdquo; software, encryption or other servcies to a specific Pi. Found this in a suggestion on the Stack Overflow question &lt;a href=&#34;http://stackoverflow.com/questions/27730877/securing-data-on-sd-card-raspberry-pi&#34;&gt;&amp;ldquo;Securing data on SD card Raspberry Pi&amp;rdquo;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
